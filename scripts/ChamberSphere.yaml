variables:
  - Pin
  - Qin
  - Pout
  - Qout
  - radius
  - velo
  - stress
  - tau
  - volume

derivatives:
  - dPin_dt
  - dQin_dt
  - dPout_dt
  - dQout_dt
  - dradius_dt
  - dvelo_dt
  - dstress_dt
  - dtau_dt
  - dvolume_dt

constants:
  - rho
  - thick0
  - radius0
  - W1
  - W2
  - eta
  - act
  - act_plus
  - sigma_max

time_dependent:
  - act
  - act_plus

helper_functions: |
  def CG(radius):
      return (1 + (radius / radius0)) ** 2

  def dCG(radius, dradius_dt):
      return 2 * (1 + (radius / radius0)) * (1 / radius0) * dradius_dt

residuals:
  - rho * thick0 * dvelo_dt + (thick0 / radius0) * (1 + (radius / radius0)) * stress - Pout * CG(radius)
  # The problem is the derivative dvelo_dt - through chain rule? dvelo_dt = d(dradius_dt)/dt

  - -stress + tau + 4 * (1 - CG(radius) ** -3) * (W1 + CG(radius) * W2) + 2 * eta * dCG(radius, dradius_dt) * (1 - 2 * CG(radius) ** -6)
  # from eq.2 stress = tau + 4 * (1 - CG(radius) ** -3) * (W1 + CG(radius) * W2) + 2 * eta * dCG(radius, dradius_dt) * (1 - 2 * CG(radius) ** -6)
  # sigma_passive = 4 * (1 - CG(radius) ** -3) * (W1 + CG(radius) * W2)

  - 4 * pi * radius0 ** 2 * CG(radius) * velo - dvolume_dt 
  # From eq. 5 velo = dradius_dt so eq. 3 becomes:
  # 4 * pi * radius0 ** 2 * CG(radius) * dradius_dt - dvolume_dt 
  # But radius = (3/4pi * volume)^(1/3) - radius0 
  # and from eq.3 dradius_dt = dvolume_dt/(4 * pi * radius0 ** 2 * CG(radius))

  - dtau_dt + act * tau - sigma_max * act_plus
  # Provided as input for now

  - dradius_dt - velo 
  # velo = dradius_dt 

  - Qin - Qout - dvolume_dt 
  # All provided as inputs

  - Pin - Pout